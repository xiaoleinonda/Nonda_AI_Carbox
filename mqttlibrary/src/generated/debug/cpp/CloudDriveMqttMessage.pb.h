// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CloudDriveMqttMessage.proto

#ifndef PROTOBUF_CloudDriveMqttMessage_2eproto__INCLUDED
#define PROTOBUF_CloudDriveMqttMessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
// @@protoc_insertion_point(includes)
namespace io {
namespace nonda {
namespace onedata {
namespace proto {
namespace contract {
class CloudDriveMqttBoxStatusData;
class CloudDriveMqttBoxStatusDataDefaultTypeInternal;
extern CloudDriveMqttBoxStatusDataDefaultTypeInternal _CloudDriveMqttBoxStatusData_default_instance_;
class CloudDriveMqttEmotionData;
class CloudDriveMqttEmotionDataDefaultTypeInternal;
extern CloudDriveMqttEmotionDataDefaultTypeInternal _CloudDriveMqttEmotionData_default_instance_;
class CloudDriveMqttEmotionDataItem;
class CloudDriveMqttEmotionDataItemDefaultTypeInternal;
extern CloudDriveMqttEmotionDataItemDefaultTypeInternal _CloudDriveMqttEmotionDataItem_default_instance_;
class CloudDriveMqttEventData;
class CloudDriveMqttEventDataDefaultTypeInternal;
extern CloudDriveMqttEventDataDefaultTypeInternal _CloudDriveMqttEventData_default_instance_;
class CloudDriveMqttFaceData;
class CloudDriveMqttFaceDataDefaultTypeInternal;
extern CloudDriveMqttFaceDataDefaultTypeInternal _CloudDriveMqttFaceData_default_instance_;
class CloudDriveMqttFaceDataItem;
class CloudDriveMqttFaceDataItemDefaultTypeInternal;
extern CloudDriveMqttFaceDataItemDefaultTypeInternal _CloudDriveMqttFaceDataItem_default_instance_;
class CloudDriveMqttFreqData;
class CloudDriveMqttFreqDataDefaultTypeInternal;
extern CloudDriveMqttFreqDataDefaultTypeInternal _CloudDriveMqttFreqData_default_instance_;
class CloudDriveMqttGSensorData;
class CloudDriveMqttGSensorDataDefaultTypeInternal;
extern CloudDriveMqttGSensorDataDefaultTypeInternal _CloudDriveMqttGSensorData_default_instance_;
class CloudDriveMqttGSensorDataItem;
class CloudDriveMqttGSensorDataItemDefaultTypeInternal;
extern CloudDriveMqttGSensorDataItemDefaultTypeInternal _CloudDriveMqttGSensorDataItem_default_instance_;
class CloudDriveMqttGpsData;
class CloudDriveMqttGpsDataDefaultTypeInternal;
extern CloudDriveMqttGpsDataDefaultTypeInternal _CloudDriveMqttGpsData_default_instance_;
class CloudDriveMqttGpsDataItem;
class CloudDriveMqttGpsDataItemDefaultTypeInternal;
extern CloudDriveMqttGpsDataItemDefaultTypeInternal _CloudDriveMqttGpsDataItem_default_instance_;
class CloudDriveMqttGyroData;
class CloudDriveMqttGyroDataDefaultTypeInternal;
extern CloudDriveMqttGyroDataDefaultTypeInternal _CloudDriveMqttGyroData_default_instance_;
class CloudDriveMqttGyroDataItem;
class CloudDriveMqttGyroDataItemDefaultTypeInternal;
extern CloudDriveMqttGyroDataItemDefaultTypeInternal _CloudDriveMqttGyroDataItem_default_instance_;
class CloudDriveMqttLogData;
class CloudDriveMqttLogDataDefaultTypeInternal;
extern CloudDriveMqttLogDataDefaultTypeInternal _CloudDriveMqttLogData_default_instance_;
class CloudDriveMqttMessage;
class CloudDriveMqttMessageDefaultTypeInternal;
extern CloudDriveMqttMessageDefaultTypeInternal _CloudDriveMqttMessage_default_instance_;
class CloudDriveMqttReportStatusData;
class CloudDriveMqttReportStatusDataDefaultTypeInternal;
extern CloudDriveMqttReportStatusDataDefaultTypeInternal _CloudDriveMqttReportStatusData_default_instance_;
}  // namespace contract
}  // namespace proto
}  // namespace onedata
}  // namespace nonda
}  // namespace io

namespace io {
namespace nonda {
namespace onedata {
namespace proto {
namespace contract {

namespace protobuf_CloudDriveMqttMessage_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_CloudDriveMqttMessage_2eproto

// ===================================================================

class CloudDriveMqttMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.nonda.onedata.proto.contract.CloudDriveMqttMessage) */ {
 public:
  CloudDriveMqttMessage();
  virtual ~CloudDriveMqttMessage();

  CloudDriveMqttMessage(const CloudDriveMqttMessage& from);

  inline CloudDriveMqttMessage& operator=(const CloudDriveMqttMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloudDriveMqttMessage(CloudDriveMqttMessage&& from) noexcept
    : CloudDriveMqttMessage() {
    *this = ::std::move(from);
  }

  inline CloudDriveMqttMessage& operator=(CloudDriveMqttMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CloudDriveMqttMessage& default_instance();

  static inline const CloudDriveMqttMessage* internal_default_instance() {
    return reinterpret_cast<const CloudDriveMqttMessage*>(
               &_CloudDriveMqttMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(CloudDriveMqttMessage* other);
  friend void swap(CloudDriveMqttMessage& a, CloudDriveMqttMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloudDriveMqttMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  CloudDriveMqttMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CloudDriveMqttMessage& from);
  void MergeFrom(const CloudDriveMqttMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CloudDriveMqttMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Any data = 3;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::google::protobuf::Any& data() const;
  ::google::protobuf::Any* mutable_data();
  ::google::protobuf::Any* release_data();
  void set_allocated_data(::google::protobuf::Any* data);

  // int64 time = 2;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  ::google::protobuf::int64 time() const;
  void set_time(::google::protobuf::int64 value);

  // int32 cmd = 1;
  void clear_cmd();
  static const int kCmdFieldNumber = 1;
  ::google::protobuf::int32 cmd() const;
  void set_cmd(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:io.nonda.onedata.proto.contract.CloudDriveMqttMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Any* data_;
  ::google::protobuf::int64 time_;
  ::google::protobuf::int32 cmd_;
  mutable int _cached_size_;
  friend struct protobuf_CloudDriveMqttMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CloudDriveMqttBoxStatusData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.nonda.onedata.proto.contract.CloudDriveMqttBoxStatusData) */ {
 public:
  CloudDriveMqttBoxStatusData();
  virtual ~CloudDriveMqttBoxStatusData();

  CloudDriveMqttBoxStatusData(const CloudDriveMqttBoxStatusData& from);

  inline CloudDriveMqttBoxStatusData& operator=(const CloudDriveMqttBoxStatusData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloudDriveMqttBoxStatusData(CloudDriveMqttBoxStatusData&& from) noexcept
    : CloudDriveMqttBoxStatusData() {
    *this = ::std::move(from);
  }

  inline CloudDriveMqttBoxStatusData& operator=(CloudDriveMqttBoxStatusData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CloudDriveMqttBoxStatusData& default_instance();

  static inline const CloudDriveMqttBoxStatusData* internal_default_instance() {
    return reinterpret_cast<const CloudDriveMqttBoxStatusData*>(
               &_CloudDriveMqttBoxStatusData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(CloudDriveMqttBoxStatusData* other);
  friend void swap(CloudDriveMqttBoxStatusData& a, CloudDriveMqttBoxStatusData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloudDriveMqttBoxStatusData* New() const PROTOBUF_FINAL { return New(NULL); }

  CloudDriveMqttBoxStatusData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CloudDriveMqttBoxStatusData& from);
  void MergeFrom(const CloudDriveMqttBoxStatusData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CloudDriveMqttBoxStatusData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string fw = 1;
  void clear_fw();
  static const int kFwFieldNumber = 1;
  const ::std::string& fw() const;
  void set_fw(const ::std::string& value);
  #if LANG_CXX11
  void set_fw(::std::string&& value);
  #endif
  void set_fw(const char* value);
  void set_fw(const char* value, size_t size);
  ::std::string* mutable_fw();
  ::std::string* release_fw();
  void set_allocated_fw(::std::string* fw);

  // string app = 2;
  void clear_app();
  static const int kAppFieldNumber = 2;
  const ::std::string& app() const;
  void set_app(const ::std::string& value);
  #if LANG_CXX11
  void set_app(::std::string&& value);
  #endif
  void set_app(const char* value);
  void set_app(const char* value, size_t size);
  ::std::string* mutable_app();
  ::std::string* release_app();
  void set_allocated_app(::std::string* app);

  // double lat = 3;
  void clear_lat();
  static const int kLatFieldNumber = 3;
  double lat() const;
  void set_lat(double value);

  // double lng = 4;
  void clear_lng();
  static const int kLngFieldNumber = 4;
  double lng() const;
  void set_lng(double value);

  // float acc = 5;
  void clear_acc();
  static const int kAccFieldNumber = 5;
  float acc() const;
  void set_acc(float value);

  // float vol = 6;
  void clear_vol();
  static const int kVolFieldNumber = 6;
  float vol() const;
  void set_vol(float value);

  // @@protoc_insertion_point(class_scope:io.nonda.onedata.proto.contract.CloudDriveMqttBoxStatusData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr fw_;
  ::google::protobuf::internal::ArenaStringPtr app_;
  double lat_;
  double lng_;
  float acc_;
  float vol_;
  mutable int _cached_size_;
  friend struct protobuf_CloudDriveMqttMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CloudDriveMqttEventData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.nonda.onedata.proto.contract.CloudDriveMqttEventData) */ {
 public:
  CloudDriveMqttEventData();
  virtual ~CloudDriveMqttEventData();

  CloudDriveMqttEventData(const CloudDriveMqttEventData& from);

  inline CloudDriveMqttEventData& operator=(const CloudDriveMqttEventData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloudDriveMqttEventData(CloudDriveMqttEventData&& from) noexcept
    : CloudDriveMqttEventData() {
    *this = ::std::move(from);
  }

  inline CloudDriveMqttEventData& operator=(CloudDriveMqttEventData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CloudDriveMqttEventData& default_instance();

  static inline const CloudDriveMqttEventData* internal_default_instance() {
    return reinterpret_cast<const CloudDriveMqttEventData*>(
               &_CloudDriveMqttEventData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(CloudDriveMqttEventData* other);
  friend void swap(CloudDriveMqttEventData& a, CloudDriveMqttEventData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloudDriveMqttEventData* New() const PROTOBUF_FINAL { return New(NULL); }

  CloudDriveMqttEventData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CloudDriveMqttEventData& from);
  void MergeFrom(const CloudDriveMqttEventData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CloudDriveMqttEventData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string fw = 1;
  void clear_fw();
  static const int kFwFieldNumber = 1;
  const ::std::string& fw() const;
  void set_fw(const ::std::string& value);
  #if LANG_CXX11
  void set_fw(::std::string&& value);
  #endif
  void set_fw(const char* value);
  void set_fw(const char* value, size_t size);
  ::std::string* mutable_fw();
  ::std::string* release_fw();
  void set_allocated_fw(::std::string* fw);

  // string app = 2;
  void clear_app();
  static const int kAppFieldNumber = 2;
  const ::std::string& app() const;
  void set_app(const ::std::string& value);
  #if LANG_CXX11
  void set_app(::std::string&& value);
  #endif
  void set_app(const char* value);
  void set_app(const char* value, size_t size);
  ::std::string* mutable_app();
  ::std::string* release_app();
  void set_allocated_app(::std::string* app);

  // string content = 8;
  void clear_content();
  static const int kContentFieldNumber = 8;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // double lat = 3;
  void clear_lat();
  static const int kLatFieldNumber = 3;
  double lat() const;
  void set_lat(double value);

  // double lng = 4;
  void clear_lng();
  static const int kLngFieldNumber = 4;
  double lng() const;
  void set_lng(double value);

  // float acc = 5;
  void clear_acc();
  static const int kAccFieldNumber = 5;
  float acc() const;
  void set_acc(float value);

  // float vol = 6;
  void clear_vol();
  static const int kVolFieldNumber = 6;
  float vol() const;
  void set_vol(float value);

  // int32 type = 7;
  void clear_type();
  static const int kTypeFieldNumber = 7;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:io.nonda.onedata.proto.contract.CloudDriveMqttEventData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr fw_;
  ::google::protobuf::internal::ArenaStringPtr app_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  double lat_;
  double lng_;
  float acc_;
  float vol_;
  ::google::protobuf::int32 type_;
  mutable int _cached_size_;
  friend struct protobuf_CloudDriveMqttMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CloudDriveMqttGpsData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.nonda.onedata.proto.contract.CloudDriveMqttGpsData) */ {
 public:
  CloudDriveMqttGpsData();
  virtual ~CloudDriveMqttGpsData();

  CloudDriveMqttGpsData(const CloudDriveMqttGpsData& from);

  inline CloudDriveMqttGpsData& operator=(const CloudDriveMqttGpsData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloudDriveMqttGpsData(CloudDriveMqttGpsData&& from) noexcept
    : CloudDriveMqttGpsData() {
    *this = ::std::move(from);
  }

  inline CloudDriveMqttGpsData& operator=(CloudDriveMqttGpsData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CloudDriveMqttGpsData& default_instance();

  static inline const CloudDriveMqttGpsData* internal_default_instance() {
    return reinterpret_cast<const CloudDriveMqttGpsData*>(
               &_CloudDriveMqttGpsData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(CloudDriveMqttGpsData* other);
  friend void swap(CloudDriveMqttGpsData& a, CloudDriveMqttGpsData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloudDriveMqttGpsData* New() const PROTOBUF_FINAL { return New(NULL); }

  CloudDriveMqttGpsData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CloudDriveMqttGpsData& from);
  void MergeFrom(const CloudDriveMqttGpsData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CloudDriveMqttGpsData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .io.nonda.onedata.proto.contract.CloudDriveMqttGpsDataItem items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  const ::io::nonda::onedata::proto::contract::CloudDriveMqttGpsDataItem& items(int index) const;
  ::io::nonda::onedata::proto::contract::CloudDriveMqttGpsDataItem* mutable_items(int index);
  ::io::nonda::onedata::proto::contract::CloudDriveMqttGpsDataItem* add_items();
  ::google::protobuf::RepeatedPtrField< ::io::nonda::onedata::proto::contract::CloudDriveMqttGpsDataItem >*
      mutable_items();
  const ::google::protobuf::RepeatedPtrField< ::io::nonda::onedata::proto::contract::CloudDriveMqttGpsDataItem >&
      items() const;

  // @@protoc_insertion_point(class_scope:io.nonda.onedata.proto.contract.CloudDriveMqttGpsData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::io::nonda::onedata::proto::contract::CloudDriveMqttGpsDataItem > items_;
  mutable int _cached_size_;
  friend struct protobuf_CloudDriveMqttMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CloudDriveMqttGpsDataItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.nonda.onedata.proto.contract.CloudDriveMqttGpsDataItem) */ {
 public:
  CloudDriveMqttGpsDataItem();
  virtual ~CloudDriveMqttGpsDataItem();

  CloudDriveMqttGpsDataItem(const CloudDriveMqttGpsDataItem& from);

  inline CloudDriveMqttGpsDataItem& operator=(const CloudDriveMqttGpsDataItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloudDriveMqttGpsDataItem(CloudDriveMqttGpsDataItem&& from) noexcept
    : CloudDriveMqttGpsDataItem() {
    *this = ::std::move(from);
  }

  inline CloudDriveMqttGpsDataItem& operator=(CloudDriveMqttGpsDataItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CloudDriveMqttGpsDataItem& default_instance();

  static inline const CloudDriveMqttGpsDataItem* internal_default_instance() {
    return reinterpret_cast<const CloudDriveMqttGpsDataItem*>(
               &_CloudDriveMqttGpsDataItem_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(CloudDriveMqttGpsDataItem* other);
  friend void swap(CloudDriveMqttGpsDataItem& a, CloudDriveMqttGpsDataItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloudDriveMqttGpsDataItem* New() const PROTOBUF_FINAL { return New(NULL); }

  CloudDriveMqttGpsDataItem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CloudDriveMqttGpsDataItem& from);
  void MergeFrom(const CloudDriveMqttGpsDataItem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CloudDriveMqttGpsDataItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 time = 1;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  ::google::protobuf::int64 time() const;
  void set_time(::google::protobuf::int64 value);

  // double lat = 2;
  void clear_lat();
  static const int kLatFieldNumber = 2;
  double lat() const;
  void set_lat(double value);

  // double lng = 3;
  void clear_lng();
  static const int kLngFieldNumber = 3;
  double lng() const;
  void set_lng(double value);

  // float spd = 4;
  void clear_spd();
  static const int kSpdFieldNumber = 4;
  float spd() const;
  void set_spd(float value);

  // float acc = 5;
  void clear_acc();
  static const int kAccFieldNumber = 5;
  float acc() const;
  void set_acc(float value);

  // float brg = 6;
  void clear_brg();
  static const int kBrgFieldNumber = 6;
  float brg() const;
  void set_brg(float value);

  // @@protoc_insertion_point(class_scope:io.nonda.onedata.proto.contract.CloudDriveMqttGpsDataItem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 time_;
  double lat_;
  double lng_;
  float spd_;
  float acc_;
  float brg_;
  mutable int _cached_size_;
  friend struct protobuf_CloudDriveMqttMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CloudDriveMqttGSensorData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.nonda.onedata.proto.contract.CloudDriveMqttGSensorData) */ {
 public:
  CloudDriveMqttGSensorData();
  virtual ~CloudDriveMqttGSensorData();

  CloudDriveMqttGSensorData(const CloudDriveMqttGSensorData& from);

  inline CloudDriveMqttGSensorData& operator=(const CloudDriveMqttGSensorData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloudDriveMqttGSensorData(CloudDriveMqttGSensorData&& from) noexcept
    : CloudDriveMqttGSensorData() {
    *this = ::std::move(from);
  }

  inline CloudDriveMqttGSensorData& operator=(CloudDriveMqttGSensorData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CloudDriveMqttGSensorData& default_instance();

  static inline const CloudDriveMqttGSensorData* internal_default_instance() {
    return reinterpret_cast<const CloudDriveMqttGSensorData*>(
               &_CloudDriveMqttGSensorData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(CloudDriveMqttGSensorData* other);
  friend void swap(CloudDriveMqttGSensorData& a, CloudDriveMqttGSensorData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloudDriveMqttGSensorData* New() const PROTOBUF_FINAL { return New(NULL); }

  CloudDriveMqttGSensorData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CloudDriveMqttGSensorData& from);
  void MergeFrom(const CloudDriveMqttGSensorData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CloudDriveMqttGSensorData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .io.nonda.onedata.proto.contract.CloudDriveMqttGSensorDataItem items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  const ::io::nonda::onedata::proto::contract::CloudDriveMqttGSensorDataItem& items(int index) const;
  ::io::nonda::onedata::proto::contract::CloudDriveMqttGSensorDataItem* mutable_items(int index);
  ::io::nonda::onedata::proto::contract::CloudDriveMqttGSensorDataItem* add_items();
  ::google::protobuf::RepeatedPtrField< ::io::nonda::onedata::proto::contract::CloudDriveMqttGSensorDataItem >*
      mutable_items();
  const ::google::protobuf::RepeatedPtrField< ::io::nonda::onedata::proto::contract::CloudDriveMqttGSensorDataItem >&
      items() const;

  // @@protoc_insertion_point(class_scope:io.nonda.onedata.proto.contract.CloudDriveMqttGSensorData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::io::nonda::onedata::proto::contract::CloudDriveMqttGSensorDataItem > items_;
  mutable int _cached_size_;
  friend struct protobuf_CloudDriveMqttMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CloudDriveMqttGSensorDataItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.nonda.onedata.proto.contract.CloudDriveMqttGSensorDataItem) */ {
 public:
  CloudDriveMqttGSensorDataItem();
  virtual ~CloudDriveMqttGSensorDataItem();

  CloudDriveMqttGSensorDataItem(const CloudDriveMqttGSensorDataItem& from);

  inline CloudDriveMqttGSensorDataItem& operator=(const CloudDriveMqttGSensorDataItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloudDriveMqttGSensorDataItem(CloudDriveMqttGSensorDataItem&& from) noexcept
    : CloudDriveMqttGSensorDataItem() {
    *this = ::std::move(from);
  }

  inline CloudDriveMqttGSensorDataItem& operator=(CloudDriveMqttGSensorDataItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CloudDriveMqttGSensorDataItem& default_instance();

  static inline const CloudDriveMqttGSensorDataItem* internal_default_instance() {
    return reinterpret_cast<const CloudDriveMqttGSensorDataItem*>(
               &_CloudDriveMqttGSensorDataItem_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(CloudDriveMqttGSensorDataItem* other);
  friend void swap(CloudDriveMqttGSensorDataItem& a, CloudDriveMqttGSensorDataItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloudDriveMqttGSensorDataItem* New() const PROTOBUF_FINAL { return New(NULL); }

  CloudDriveMqttGSensorDataItem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CloudDriveMqttGSensorDataItem& from);
  void MergeFrom(const CloudDriveMqttGSensorDataItem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CloudDriveMqttGSensorDataItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 time = 1;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  ::google::protobuf::int64 time() const;
  void set_time(::google::protobuf::int64 value);

  // float x = 2;
  void clear_x();
  static const int kXFieldNumber = 2;
  float x() const;
  void set_x(float value);

  // float y = 3;
  void clear_y();
  static const int kYFieldNumber = 3;
  float y() const;
  void set_y(float value);

  // float z = 4;
  void clear_z();
  static const int kZFieldNumber = 4;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:io.nonda.onedata.proto.contract.CloudDriveMqttGSensorDataItem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 time_;
  float x_;
  float y_;
  float z_;
  mutable int _cached_size_;
  friend struct protobuf_CloudDriveMqttMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CloudDriveMqttGyroData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.nonda.onedata.proto.contract.CloudDriveMqttGyroData) */ {
 public:
  CloudDriveMqttGyroData();
  virtual ~CloudDriveMqttGyroData();

  CloudDriveMqttGyroData(const CloudDriveMqttGyroData& from);

  inline CloudDriveMqttGyroData& operator=(const CloudDriveMqttGyroData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloudDriveMqttGyroData(CloudDriveMqttGyroData&& from) noexcept
    : CloudDriveMqttGyroData() {
    *this = ::std::move(from);
  }

  inline CloudDriveMqttGyroData& operator=(CloudDriveMqttGyroData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CloudDriveMqttGyroData& default_instance();

  static inline const CloudDriveMqttGyroData* internal_default_instance() {
    return reinterpret_cast<const CloudDriveMqttGyroData*>(
               &_CloudDriveMqttGyroData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(CloudDriveMqttGyroData* other);
  friend void swap(CloudDriveMqttGyroData& a, CloudDriveMqttGyroData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloudDriveMqttGyroData* New() const PROTOBUF_FINAL { return New(NULL); }

  CloudDriveMqttGyroData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CloudDriveMqttGyroData& from);
  void MergeFrom(const CloudDriveMqttGyroData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CloudDriveMqttGyroData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .io.nonda.onedata.proto.contract.CloudDriveMqttGyroDataItem items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  const ::io::nonda::onedata::proto::contract::CloudDriveMqttGyroDataItem& items(int index) const;
  ::io::nonda::onedata::proto::contract::CloudDriveMqttGyroDataItem* mutable_items(int index);
  ::io::nonda::onedata::proto::contract::CloudDriveMqttGyroDataItem* add_items();
  ::google::protobuf::RepeatedPtrField< ::io::nonda::onedata::proto::contract::CloudDriveMqttGyroDataItem >*
      mutable_items();
  const ::google::protobuf::RepeatedPtrField< ::io::nonda::onedata::proto::contract::CloudDriveMqttGyroDataItem >&
      items() const;

  // @@protoc_insertion_point(class_scope:io.nonda.onedata.proto.contract.CloudDriveMqttGyroData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::io::nonda::onedata::proto::contract::CloudDriveMqttGyroDataItem > items_;
  mutable int _cached_size_;
  friend struct protobuf_CloudDriveMqttMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CloudDriveMqttGyroDataItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.nonda.onedata.proto.contract.CloudDriveMqttGyroDataItem) */ {
 public:
  CloudDriveMqttGyroDataItem();
  virtual ~CloudDriveMqttGyroDataItem();

  CloudDriveMqttGyroDataItem(const CloudDriveMqttGyroDataItem& from);

  inline CloudDriveMqttGyroDataItem& operator=(const CloudDriveMqttGyroDataItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloudDriveMqttGyroDataItem(CloudDriveMqttGyroDataItem&& from) noexcept
    : CloudDriveMqttGyroDataItem() {
    *this = ::std::move(from);
  }

  inline CloudDriveMqttGyroDataItem& operator=(CloudDriveMqttGyroDataItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CloudDriveMqttGyroDataItem& default_instance();

  static inline const CloudDriveMqttGyroDataItem* internal_default_instance() {
    return reinterpret_cast<const CloudDriveMqttGyroDataItem*>(
               &_CloudDriveMqttGyroDataItem_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(CloudDriveMqttGyroDataItem* other);
  friend void swap(CloudDriveMqttGyroDataItem& a, CloudDriveMqttGyroDataItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloudDriveMqttGyroDataItem* New() const PROTOBUF_FINAL { return New(NULL); }

  CloudDriveMqttGyroDataItem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CloudDriveMqttGyroDataItem& from);
  void MergeFrom(const CloudDriveMqttGyroDataItem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CloudDriveMqttGyroDataItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 time = 1;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  ::google::protobuf::int64 time() const;
  void set_time(::google::protobuf::int64 value);

  // float x = 2;
  void clear_x();
  static const int kXFieldNumber = 2;
  float x() const;
  void set_x(float value);

  // float y = 3;
  void clear_y();
  static const int kYFieldNumber = 3;
  float y() const;
  void set_y(float value);

  // float z = 4;
  void clear_z();
  static const int kZFieldNumber = 4;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:io.nonda.onedata.proto.contract.CloudDriveMqttGyroDataItem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 time_;
  float x_;
  float y_;
  float z_;
  mutable int _cached_size_;
  friend struct protobuf_CloudDriveMqttMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CloudDriveMqttFreqData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.nonda.onedata.proto.contract.CloudDriveMqttFreqData) */ {
 public:
  CloudDriveMqttFreqData();
  virtual ~CloudDriveMqttFreqData();

  CloudDriveMqttFreqData(const CloudDriveMqttFreqData& from);

  inline CloudDriveMqttFreqData& operator=(const CloudDriveMqttFreqData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloudDriveMqttFreqData(CloudDriveMqttFreqData&& from) noexcept
    : CloudDriveMqttFreqData() {
    *this = ::std::move(from);
  }

  inline CloudDriveMqttFreqData& operator=(CloudDriveMqttFreqData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CloudDriveMqttFreqData& default_instance();

  static inline const CloudDriveMqttFreqData* internal_default_instance() {
    return reinterpret_cast<const CloudDriveMqttFreqData*>(
               &_CloudDriveMqttFreqData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(CloudDriveMqttFreqData* other);
  friend void swap(CloudDriveMqttFreqData& a, CloudDriveMqttFreqData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloudDriveMqttFreqData* New() const PROTOBUF_FINAL { return New(NULL); }

  CloudDriveMqttFreqData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CloudDriveMqttFreqData& from);
  void MergeFrom(const CloudDriveMqttFreqData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CloudDriveMqttFreqData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 collectFreq = 1;
  void clear_collectfreq();
  static const int kCollectFreqFieldNumber = 1;
  ::google::protobuf::int32 collectfreq() const;
  void set_collectfreq(::google::protobuf::int32 value);

  // int32 reportFreq = 2;
  void clear_reportfreq();
  static const int kReportFreqFieldNumber = 2;
  ::google::protobuf::int32 reportfreq() const;
  void set_reportfreq(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:io.nonda.onedata.proto.contract.CloudDriveMqttFreqData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 collectfreq_;
  ::google::protobuf::int32 reportfreq_;
  mutable int _cached_size_;
  friend struct protobuf_CloudDriveMqttMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CloudDriveMqttFaceData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.nonda.onedata.proto.contract.CloudDriveMqttFaceData) */ {
 public:
  CloudDriveMqttFaceData();
  virtual ~CloudDriveMqttFaceData();

  CloudDriveMqttFaceData(const CloudDriveMqttFaceData& from);

  inline CloudDriveMqttFaceData& operator=(const CloudDriveMqttFaceData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloudDriveMqttFaceData(CloudDriveMqttFaceData&& from) noexcept
    : CloudDriveMqttFaceData() {
    *this = ::std::move(from);
  }

  inline CloudDriveMqttFaceData& operator=(CloudDriveMqttFaceData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CloudDriveMqttFaceData& default_instance();

  static inline const CloudDriveMqttFaceData* internal_default_instance() {
    return reinterpret_cast<const CloudDriveMqttFaceData*>(
               &_CloudDriveMqttFaceData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(CloudDriveMqttFaceData* other);
  friend void swap(CloudDriveMqttFaceData& a, CloudDriveMqttFaceData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloudDriveMqttFaceData* New() const PROTOBUF_FINAL { return New(NULL); }

  CloudDriveMqttFaceData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CloudDriveMqttFaceData& from);
  void MergeFrom(const CloudDriveMqttFaceData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CloudDriveMqttFaceData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .io.nonda.onedata.proto.contract.CloudDriveMqttFaceDataItem items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  const ::io::nonda::onedata::proto::contract::CloudDriveMqttFaceDataItem& items(int index) const;
  ::io::nonda::onedata::proto::contract::CloudDriveMqttFaceDataItem* mutable_items(int index);
  ::io::nonda::onedata::proto::contract::CloudDriveMqttFaceDataItem* add_items();
  ::google::protobuf::RepeatedPtrField< ::io::nonda::onedata::proto::contract::CloudDriveMqttFaceDataItem >*
      mutable_items();
  const ::google::protobuf::RepeatedPtrField< ::io::nonda::onedata::proto::contract::CloudDriveMqttFaceDataItem >&
      items() const;

  // @@protoc_insertion_point(class_scope:io.nonda.onedata.proto.contract.CloudDriveMqttFaceData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::io::nonda::onedata::proto::contract::CloudDriveMqttFaceDataItem > items_;
  mutable int _cached_size_;
  friend struct protobuf_CloudDriveMqttMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CloudDriveMqttFaceDataItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.nonda.onedata.proto.contract.CloudDriveMqttFaceDataItem) */ {
 public:
  CloudDriveMqttFaceDataItem();
  virtual ~CloudDriveMqttFaceDataItem();

  CloudDriveMqttFaceDataItem(const CloudDriveMqttFaceDataItem& from);

  inline CloudDriveMqttFaceDataItem& operator=(const CloudDriveMqttFaceDataItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloudDriveMqttFaceDataItem(CloudDriveMqttFaceDataItem&& from) noexcept
    : CloudDriveMqttFaceDataItem() {
    *this = ::std::move(from);
  }

  inline CloudDriveMqttFaceDataItem& operator=(CloudDriveMqttFaceDataItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CloudDriveMqttFaceDataItem& default_instance();

  static inline const CloudDriveMqttFaceDataItem* internal_default_instance() {
    return reinterpret_cast<const CloudDriveMqttFaceDataItem*>(
               &_CloudDriveMqttFaceDataItem_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(CloudDriveMqttFaceDataItem* other);
  friend void swap(CloudDriveMqttFaceDataItem& a, CloudDriveMqttFaceDataItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloudDriveMqttFaceDataItem* New() const PROTOBUF_FINAL { return New(NULL); }

  CloudDriveMqttFaceDataItem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CloudDriveMqttFaceDataItem& from);
  void MergeFrom(const CloudDriveMqttFaceDataItem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CloudDriveMqttFaceDataItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 time = 1;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  ::google::protobuf::int64 time() const;
  void set_time(::google::protobuf::int64 value);

  // int32 face = 2;
  void clear_face();
  static const int kFaceFieldNumber = 2;
  ::google::protobuf::int32 face() const;
  void set_face(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:io.nonda.onedata.proto.contract.CloudDriveMqttFaceDataItem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 time_;
  ::google::protobuf::int32 face_;
  mutable int _cached_size_;
  friend struct protobuf_CloudDriveMqttMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CloudDriveMqttEmotionData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.nonda.onedata.proto.contract.CloudDriveMqttEmotionData) */ {
 public:
  CloudDriveMqttEmotionData();
  virtual ~CloudDriveMqttEmotionData();

  CloudDriveMqttEmotionData(const CloudDriveMqttEmotionData& from);

  inline CloudDriveMqttEmotionData& operator=(const CloudDriveMqttEmotionData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloudDriveMqttEmotionData(CloudDriveMqttEmotionData&& from) noexcept
    : CloudDriveMqttEmotionData() {
    *this = ::std::move(from);
  }

  inline CloudDriveMqttEmotionData& operator=(CloudDriveMqttEmotionData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CloudDriveMqttEmotionData& default_instance();

  static inline const CloudDriveMqttEmotionData* internal_default_instance() {
    return reinterpret_cast<const CloudDriveMqttEmotionData*>(
               &_CloudDriveMqttEmotionData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(CloudDriveMqttEmotionData* other);
  friend void swap(CloudDriveMqttEmotionData& a, CloudDriveMqttEmotionData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloudDriveMqttEmotionData* New() const PROTOBUF_FINAL { return New(NULL); }

  CloudDriveMqttEmotionData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CloudDriveMqttEmotionData& from);
  void MergeFrom(const CloudDriveMqttEmotionData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CloudDriveMqttEmotionData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .io.nonda.onedata.proto.contract.CloudDriveMqttEmotionDataItem items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  const ::io::nonda::onedata::proto::contract::CloudDriveMqttEmotionDataItem& items(int index) const;
  ::io::nonda::onedata::proto::contract::CloudDriveMqttEmotionDataItem* mutable_items(int index);
  ::io::nonda::onedata::proto::contract::CloudDriveMqttEmotionDataItem* add_items();
  ::google::protobuf::RepeatedPtrField< ::io::nonda::onedata::proto::contract::CloudDriveMqttEmotionDataItem >*
      mutable_items();
  const ::google::protobuf::RepeatedPtrField< ::io::nonda::onedata::proto::contract::CloudDriveMqttEmotionDataItem >&
      items() const;

  // @@protoc_insertion_point(class_scope:io.nonda.onedata.proto.contract.CloudDriveMqttEmotionData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::io::nonda::onedata::proto::contract::CloudDriveMqttEmotionDataItem > items_;
  mutable int _cached_size_;
  friend struct protobuf_CloudDriveMqttMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CloudDriveMqttEmotionDataItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.nonda.onedata.proto.contract.CloudDriveMqttEmotionDataItem) */ {
 public:
  CloudDriveMqttEmotionDataItem();
  virtual ~CloudDriveMqttEmotionDataItem();

  CloudDriveMqttEmotionDataItem(const CloudDriveMqttEmotionDataItem& from);

  inline CloudDriveMqttEmotionDataItem& operator=(const CloudDriveMqttEmotionDataItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloudDriveMqttEmotionDataItem(CloudDriveMqttEmotionDataItem&& from) noexcept
    : CloudDriveMqttEmotionDataItem() {
    *this = ::std::move(from);
  }

  inline CloudDriveMqttEmotionDataItem& operator=(CloudDriveMqttEmotionDataItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CloudDriveMqttEmotionDataItem& default_instance();

  static inline const CloudDriveMqttEmotionDataItem* internal_default_instance() {
    return reinterpret_cast<const CloudDriveMqttEmotionDataItem*>(
               &_CloudDriveMqttEmotionDataItem_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(CloudDriveMqttEmotionDataItem* other);
  friend void swap(CloudDriveMqttEmotionDataItem& a, CloudDriveMqttEmotionDataItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloudDriveMqttEmotionDataItem* New() const PROTOBUF_FINAL { return New(NULL); }

  CloudDriveMqttEmotionDataItem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CloudDriveMqttEmotionDataItem& from);
  void MergeFrom(const CloudDriveMqttEmotionDataItem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CloudDriveMqttEmotionDataItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string emotion = 2;
  void clear_emotion();
  static const int kEmotionFieldNumber = 2;
  const ::std::string& emotion() const;
  void set_emotion(const ::std::string& value);
  #if LANG_CXX11
  void set_emotion(::std::string&& value);
  #endif
  void set_emotion(const char* value);
  void set_emotion(const char* value, size_t size);
  ::std::string* mutable_emotion();
  ::std::string* release_emotion();
  void set_allocated_emotion(::std::string* emotion);

  // int64 time = 1;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  ::google::protobuf::int64 time() const;
  void set_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:io.nonda.onedata.proto.contract.CloudDriveMqttEmotionDataItem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr emotion_;
  ::google::protobuf::int64 time_;
  mutable int _cached_size_;
  friend struct protobuf_CloudDriveMqttMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CloudDriveMqttLogData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.nonda.onedata.proto.contract.CloudDriveMqttLogData) */ {
 public:
  CloudDriveMqttLogData();
  virtual ~CloudDriveMqttLogData();

  CloudDriveMqttLogData(const CloudDriveMqttLogData& from);

  inline CloudDriveMqttLogData& operator=(const CloudDriveMqttLogData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloudDriveMqttLogData(CloudDriveMqttLogData&& from) noexcept
    : CloudDriveMqttLogData() {
    *this = ::std::move(from);
  }

  inline CloudDriveMqttLogData& operator=(CloudDriveMqttLogData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CloudDriveMqttLogData& default_instance();

  static inline const CloudDriveMqttLogData* internal_default_instance() {
    return reinterpret_cast<const CloudDriveMqttLogData*>(
               &_CloudDriveMqttLogData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(CloudDriveMqttLogData* other);
  friend void swap(CloudDriveMqttLogData& a, CloudDriveMqttLogData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloudDriveMqttLogData* New() const PROTOBUF_FINAL { return New(NULL); }

  CloudDriveMqttLogData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CloudDriveMqttLogData& from);
  void MergeFrom(const CloudDriveMqttLogData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CloudDriveMqttLogData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // string msg = 2;
  void clear_msg();
  static const int kMsgFieldNumber = 2;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_msg(::std::string&& value);
  #endif
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:io.nonda.onedata.proto.contract.CloudDriveMqttLogData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  mutable int _cached_size_;
  friend struct protobuf_CloudDriveMqttMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CloudDriveMqttReportStatusData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.nonda.onedata.proto.contract.CloudDriveMqttReportStatusData) */ {
 public:
  CloudDriveMqttReportStatusData();
  virtual ~CloudDriveMqttReportStatusData();

  CloudDriveMqttReportStatusData(const CloudDriveMqttReportStatusData& from);

  inline CloudDriveMqttReportStatusData& operator=(const CloudDriveMqttReportStatusData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloudDriveMqttReportStatusData(CloudDriveMqttReportStatusData&& from) noexcept
    : CloudDriveMqttReportStatusData() {
    *this = ::std::move(from);
  }

  inline CloudDriveMqttReportStatusData& operator=(CloudDriveMqttReportStatusData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CloudDriveMqttReportStatusData& default_instance();

  static inline const CloudDriveMqttReportStatusData* internal_default_instance() {
    return reinterpret_cast<const CloudDriveMqttReportStatusData*>(
               &_CloudDriveMqttReportStatusData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(CloudDriveMqttReportStatusData* other);
  friend void swap(CloudDriveMqttReportStatusData& a, CloudDriveMqttReportStatusData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloudDriveMqttReportStatusData* New() const PROTOBUF_FINAL { return New(NULL); }

  CloudDriveMqttReportStatusData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CloudDriveMqttReportStatusData& from);
  void MergeFrom(const CloudDriveMqttReportStatusData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CloudDriveMqttReportStatusData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:io.nonda.onedata.proto.contract.CloudDriveMqttReportStatusData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 type_;
  mutable int _cached_size_;
  friend struct protobuf_CloudDriveMqttMessage_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CloudDriveMqttMessage

// int32 cmd = 1;
inline void CloudDriveMqttMessage::clear_cmd() {
  cmd_ = 0;
}
inline ::google::protobuf::int32 CloudDriveMqttMessage::cmd() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttMessage.cmd)
  return cmd_;
}
inline void CloudDriveMqttMessage::set_cmd(::google::protobuf::int32 value) {
  
  cmd_ = value;
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttMessage.cmd)
}

// int64 time = 2;
inline void CloudDriveMqttMessage::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CloudDriveMqttMessage::time() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttMessage.time)
  return time_;
}
inline void CloudDriveMqttMessage::set_time(::google::protobuf::int64 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttMessage.time)
}

// .google.protobuf.Any data = 3;
inline bool CloudDriveMqttMessage::has_data() const {
  return this != internal_default_instance() && data_ != NULL;
}
inline void CloudDriveMqttMessage::clear_data() {
  if (GetArenaNoVirtual() == NULL && data_ != NULL) delete data_;
  data_ = NULL;
}
inline const ::google::protobuf::Any& CloudDriveMqttMessage::data() const {
  const ::google::protobuf::Any* p = data_;
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttMessage.data)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Any*>(
      &::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* CloudDriveMqttMessage::mutable_data() {
  
  if (data_ == NULL) {
    data_ = new ::google::protobuf::Any;
  }
  // @@protoc_insertion_point(field_mutable:io.nonda.onedata.proto.contract.CloudDriveMqttMessage.data)
  return data_;
}
inline ::google::protobuf::Any* CloudDriveMqttMessage::release_data() {
  // @@protoc_insertion_point(field_release:io.nonda.onedata.proto.contract.CloudDriveMqttMessage.data)
  
  ::google::protobuf::Any* temp = data_;
  data_ = NULL;
  return temp;
}
inline void CloudDriveMqttMessage::set_allocated_data(::google::protobuf::Any* data) {
  delete data_;
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:io.nonda.onedata.proto.contract.CloudDriveMqttMessage.data)
}

// -------------------------------------------------------------------

// CloudDriveMqttBoxStatusData

// string fw = 1;
inline void CloudDriveMqttBoxStatusData::clear_fw() {
  fw_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CloudDriveMqttBoxStatusData::fw() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttBoxStatusData.fw)
  return fw_.GetNoArena();
}
inline void CloudDriveMqttBoxStatusData::set_fw(const ::std::string& value) {
  
  fw_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttBoxStatusData.fw)
}
#if LANG_CXX11
inline void CloudDriveMqttBoxStatusData::set_fw(::std::string&& value) {
  
  fw_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.nonda.onedata.proto.contract.CloudDriveMqttBoxStatusData.fw)
}
#endif
inline void CloudDriveMqttBoxStatusData::set_fw(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  fw_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.nonda.onedata.proto.contract.CloudDriveMqttBoxStatusData.fw)
}
inline void CloudDriveMqttBoxStatusData::set_fw(const char* value, size_t size) {
  
  fw_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.nonda.onedata.proto.contract.CloudDriveMqttBoxStatusData.fw)
}
inline ::std::string* CloudDriveMqttBoxStatusData::mutable_fw() {
  
  // @@protoc_insertion_point(field_mutable:io.nonda.onedata.proto.contract.CloudDriveMqttBoxStatusData.fw)
  return fw_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CloudDriveMqttBoxStatusData::release_fw() {
  // @@protoc_insertion_point(field_release:io.nonda.onedata.proto.contract.CloudDriveMqttBoxStatusData.fw)
  
  return fw_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CloudDriveMqttBoxStatusData::set_allocated_fw(::std::string* fw) {
  if (fw != NULL) {
    
  } else {
    
  }
  fw_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fw);
  // @@protoc_insertion_point(field_set_allocated:io.nonda.onedata.proto.contract.CloudDriveMqttBoxStatusData.fw)
}

// string app = 2;
inline void CloudDriveMqttBoxStatusData::clear_app() {
  app_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CloudDriveMqttBoxStatusData::app() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttBoxStatusData.app)
  return app_.GetNoArena();
}
inline void CloudDriveMqttBoxStatusData::set_app(const ::std::string& value) {
  
  app_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttBoxStatusData.app)
}
#if LANG_CXX11
inline void CloudDriveMqttBoxStatusData::set_app(::std::string&& value) {
  
  app_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.nonda.onedata.proto.contract.CloudDriveMqttBoxStatusData.app)
}
#endif
inline void CloudDriveMqttBoxStatusData::set_app(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  app_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.nonda.onedata.proto.contract.CloudDriveMqttBoxStatusData.app)
}
inline void CloudDriveMqttBoxStatusData::set_app(const char* value, size_t size) {
  
  app_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.nonda.onedata.proto.contract.CloudDriveMqttBoxStatusData.app)
}
inline ::std::string* CloudDriveMqttBoxStatusData::mutable_app() {
  
  // @@protoc_insertion_point(field_mutable:io.nonda.onedata.proto.contract.CloudDriveMqttBoxStatusData.app)
  return app_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CloudDriveMqttBoxStatusData::release_app() {
  // @@protoc_insertion_point(field_release:io.nonda.onedata.proto.contract.CloudDriveMqttBoxStatusData.app)
  
  return app_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CloudDriveMqttBoxStatusData::set_allocated_app(::std::string* app) {
  if (app != NULL) {
    
  } else {
    
  }
  app_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), app);
  // @@protoc_insertion_point(field_set_allocated:io.nonda.onedata.proto.contract.CloudDriveMqttBoxStatusData.app)
}

// double lat = 3;
inline void CloudDriveMqttBoxStatusData::clear_lat() {
  lat_ = 0;
}
inline double CloudDriveMqttBoxStatusData::lat() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttBoxStatusData.lat)
  return lat_;
}
inline void CloudDriveMqttBoxStatusData::set_lat(double value) {
  
  lat_ = value;
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttBoxStatusData.lat)
}

// double lng = 4;
inline void CloudDriveMqttBoxStatusData::clear_lng() {
  lng_ = 0;
}
inline double CloudDriveMqttBoxStatusData::lng() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttBoxStatusData.lng)
  return lng_;
}
inline void CloudDriveMqttBoxStatusData::set_lng(double value) {
  
  lng_ = value;
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttBoxStatusData.lng)
}

// float acc = 5;
inline void CloudDriveMqttBoxStatusData::clear_acc() {
  acc_ = 0;
}
inline float CloudDriveMqttBoxStatusData::acc() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttBoxStatusData.acc)
  return acc_;
}
inline void CloudDriveMqttBoxStatusData::set_acc(float value) {
  
  acc_ = value;
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttBoxStatusData.acc)
}

// float vol = 6;
inline void CloudDriveMqttBoxStatusData::clear_vol() {
  vol_ = 0;
}
inline float CloudDriveMqttBoxStatusData::vol() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttBoxStatusData.vol)
  return vol_;
}
inline void CloudDriveMqttBoxStatusData::set_vol(float value) {
  
  vol_ = value;
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttBoxStatusData.vol)
}

// -------------------------------------------------------------------

// CloudDriveMqttEventData

// string fw = 1;
inline void CloudDriveMqttEventData::clear_fw() {
  fw_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CloudDriveMqttEventData::fw() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.fw)
  return fw_.GetNoArena();
}
inline void CloudDriveMqttEventData::set_fw(const ::std::string& value) {
  
  fw_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.fw)
}
#if LANG_CXX11
inline void CloudDriveMqttEventData::set_fw(::std::string&& value) {
  
  fw_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.fw)
}
#endif
inline void CloudDriveMqttEventData::set_fw(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  fw_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.fw)
}
inline void CloudDriveMqttEventData::set_fw(const char* value, size_t size) {
  
  fw_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.fw)
}
inline ::std::string* CloudDriveMqttEventData::mutable_fw() {
  
  // @@protoc_insertion_point(field_mutable:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.fw)
  return fw_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CloudDriveMqttEventData::release_fw() {
  // @@protoc_insertion_point(field_release:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.fw)
  
  return fw_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CloudDriveMqttEventData::set_allocated_fw(::std::string* fw) {
  if (fw != NULL) {
    
  } else {
    
  }
  fw_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fw);
  // @@protoc_insertion_point(field_set_allocated:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.fw)
}

// string app = 2;
inline void CloudDriveMqttEventData::clear_app() {
  app_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CloudDriveMqttEventData::app() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.app)
  return app_.GetNoArena();
}
inline void CloudDriveMqttEventData::set_app(const ::std::string& value) {
  
  app_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.app)
}
#if LANG_CXX11
inline void CloudDriveMqttEventData::set_app(::std::string&& value) {
  
  app_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.app)
}
#endif
inline void CloudDriveMqttEventData::set_app(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  app_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.app)
}
inline void CloudDriveMqttEventData::set_app(const char* value, size_t size) {
  
  app_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.app)
}
inline ::std::string* CloudDriveMqttEventData::mutable_app() {
  
  // @@protoc_insertion_point(field_mutable:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.app)
  return app_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CloudDriveMqttEventData::release_app() {
  // @@protoc_insertion_point(field_release:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.app)
  
  return app_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CloudDriveMqttEventData::set_allocated_app(::std::string* app) {
  if (app != NULL) {
    
  } else {
    
  }
  app_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), app);
  // @@protoc_insertion_point(field_set_allocated:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.app)
}

// double lat = 3;
inline void CloudDriveMqttEventData::clear_lat() {
  lat_ = 0;
}
inline double CloudDriveMqttEventData::lat() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.lat)
  return lat_;
}
inline void CloudDriveMqttEventData::set_lat(double value) {
  
  lat_ = value;
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.lat)
}

// double lng = 4;
inline void CloudDriveMqttEventData::clear_lng() {
  lng_ = 0;
}
inline double CloudDriveMqttEventData::lng() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.lng)
  return lng_;
}
inline void CloudDriveMqttEventData::set_lng(double value) {
  
  lng_ = value;
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.lng)
}

// float acc = 5;
inline void CloudDriveMqttEventData::clear_acc() {
  acc_ = 0;
}
inline float CloudDriveMqttEventData::acc() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.acc)
  return acc_;
}
inline void CloudDriveMqttEventData::set_acc(float value) {
  
  acc_ = value;
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.acc)
}

// float vol = 6;
inline void CloudDriveMqttEventData::clear_vol() {
  vol_ = 0;
}
inline float CloudDriveMqttEventData::vol() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.vol)
  return vol_;
}
inline void CloudDriveMqttEventData::set_vol(float value) {
  
  vol_ = value;
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.vol)
}

// int32 type = 7;
inline void CloudDriveMqttEventData::clear_type() {
  type_ = 0;
}
inline ::google::protobuf::int32 CloudDriveMqttEventData::type() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.type)
  return type_;
}
inline void CloudDriveMqttEventData::set_type(::google::protobuf::int32 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.type)
}

// string content = 8;
inline void CloudDriveMqttEventData::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CloudDriveMqttEventData::content() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.content)
  return content_.GetNoArena();
}
inline void CloudDriveMqttEventData::set_content(const ::std::string& value) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.content)
}
#if LANG_CXX11
inline void CloudDriveMqttEventData::set_content(::std::string&& value) {
  
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.content)
}
#endif
inline void CloudDriveMqttEventData::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.content)
}
inline void CloudDriveMqttEventData::set_content(const char* value, size_t size) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.content)
}
inline ::std::string* CloudDriveMqttEventData::mutable_content() {
  
  // @@protoc_insertion_point(field_mutable:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CloudDriveMqttEventData::release_content() {
  // @@protoc_insertion_point(field_release:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.content)
  
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CloudDriveMqttEventData::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    
  } else {
    
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:io.nonda.onedata.proto.contract.CloudDriveMqttEventData.content)
}

// -------------------------------------------------------------------

// CloudDriveMqttGpsData

// repeated .io.nonda.onedata.proto.contract.CloudDriveMqttGpsDataItem items = 1;
inline int CloudDriveMqttGpsData::items_size() const {
  return items_.size();
}
inline void CloudDriveMqttGpsData::clear_items() {
  items_.Clear();
}
inline const ::io::nonda::onedata::proto::contract::CloudDriveMqttGpsDataItem& CloudDriveMqttGpsData::items(int index) const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttGpsData.items)
  return items_.Get(index);
}
inline ::io::nonda::onedata::proto::contract::CloudDriveMqttGpsDataItem* CloudDriveMqttGpsData::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:io.nonda.onedata.proto.contract.CloudDriveMqttGpsData.items)
  return items_.Mutable(index);
}
inline ::io::nonda::onedata::proto::contract::CloudDriveMqttGpsDataItem* CloudDriveMqttGpsData::add_items() {
  // @@protoc_insertion_point(field_add:io.nonda.onedata.proto.contract.CloudDriveMqttGpsData.items)
  return items_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::io::nonda::onedata::proto::contract::CloudDriveMqttGpsDataItem >*
CloudDriveMqttGpsData::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:io.nonda.onedata.proto.contract.CloudDriveMqttGpsData.items)
  return &items_;
}
inline const ::google::protobuf::RepeatedPtrField< ::io::nonda::onedata::proto::contract::CloudDriveMqttGpsDataItem >&
CloudDriveMqttGpsData::items() const {
  // @@protoc_insertion_point(field_list:io.nonda.onedata.proto.contract.CloudDriveMqttGpsData.items)
  return items_;
}

// -------------------------------------------------------------------

// CloudDriveMqttGpsDataItem

// int64 time = 1;
inline void CloudDriveMqttGpsDataItem::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CloudDriveMqttGpsDataItem::time() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttGpsDataItem.time)
  return time_;
}
inline void CloudDriveMqttGpsDataItem::set_time(::google::protobuf::int64 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttGpsDataItem.time)
}

// double lat = 2;
inline void CloudDriveMqttGpsDataItem::clear_lat() {
  lat_ = 0;
}
inline double CloudDriveMqttGpsDataItem::lat() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttGpsDataItem.lat)
  return lat_;
}
inline void CloudDriveMqttGpsDataItem::set_lat(double value) {
  
  lat_ = value;
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttGpsDataItem.lat)
}

// double lng = 3;
inline void CloudDriveMqttGpsDataItem::clear_lng() {
  lng_ = 0;
}
inline double CloudDriveMqttGpsDataItem::lng() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttGpsDataItem.lng)
  return lng_;
}
inline void CloudDriveMqttGpsDataItem::set_lng(double value) {
  
  lng_ = value;
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttGpsDataItem.lng)
}

// float spd = 4;
inline void CloudDriveMqttGpsDataItem::clear_spd() {
  spd_ = 0;
}
inline float CloudDriveMqttGpsDataItem::spd() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttGpsDataItem.spd)
  return spd_;
}
inline void CloudDriveMqttGpsDataItem::set_spd(float value) {
  
  spd_ = value;
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttGpsDataItem.spd)
}

// float acc = 5;
inline void CloudDriveMqttGpsDataItem::clear_acc() {
  acc_ = 0;
}
inline float CloudDriveMqttGpsDataItem::acc() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttGpsDataItem.acc)
  return acc_;
}
inline void CloudDriveMqttGpsDataItem::set_acc(float value) {
  
  acc_ = value;
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttGpsDataItem.acc)
}

// float brg = 6;
inline void CloudDriveMqttGpsDataItem::clear_brg() {
  brg_ = 0;
}
inline float CloudDriveMqttGpsDataItem::brg() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttGpsDataItem.brg)
  return brg_;
}
inline void CloudDriveMqttGpsDataItem::set_brg(float value) {
  
  brg_ = value;
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttGpsDataItem.brg)
}

// -------------------------------------------------------------------

// CloudDriveMqttGSensorData

// repeated .io.nonda.onedata.proto.contract.CloudDriveMqttGSensorDataItem items = 1;
inline int CloudDriveMqttGSensorData::items_size() const {
  return items_.size();
}
inline void CloudDriveMqttGSensorData::clear_items() {
  items_.Clear();
}
inline const ::io::nonda::onedata::proto::contract::CloudDriveMqttGSensorDataItem& CloudDriveMqttGSensorData::items(int index) const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttGSensorData.items)
  return items_.Get(index);
}
inline ::io::nonda::onedata::proto::contract::CloudDriveMqttGSensorDataItem* CloudDriveMqttGSensorData::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:io.nonda.onedata.proto.contract.CloudDriveMqttGSensorData.items)
  return items_.Mutable(index);
}
inline ::io::nonda::onedata::proto::contract::CloudDriveMqttGSensorDataItem* CloudDriveMqttGSensorData::add_items() {
  // @@protoc_insertion_point(field_add:io.nonda.onedata.proto.contract.CloudDriveMqttGSensorData.items)
  return items_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::io::nonda::onedata::proto::contract::CloudDriveMqttGSensorDataItem >*
CloudDriveMqttGSensorData::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:io.nonda.onedata.proto.contract.CloudDriveMqttGSensorData.items)
  return &items_;
}
inline const ::google::protobuf::RepeatedPtrField< ::io::nonda::onedata::proto::contract::CloudDriveMqttGSensorDataItem >&
CloudDriveMqttGSensorData::items() const {
  // @@protoc_insertion_point(field_list:io.nonda.onedata.proto.contract.CloudDriveMqttGSensorData.items)
  return items_;
}

// -------------------------------------------------------------------

// CloudDriveMqttGSensorDataItem

// int64 time = 1;
inline void CloudDriveMqttGSensorDataItem::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CloudDriveMqttGSensorDataItem::time() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttGSensorDataItem.time)
  return time_;
}
inline void CloudDriveMqttGSensorDataItem::set_time(::google::protobuf::int64 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttGSensorDataItem.time)
}

// float x = 2;
inline void CloudDriveMqttGSensorDataItem::clear_x() {
  x_ = 0;
}
inline float CloudDriveMqttGSensorDataItem::x() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttGSensorDataItem.x)
  return x_;
}
inline void CloudDriveMqttGSensorDataItem::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttGSensorDataItem.x)
}

// float y = 3;
inline void CloudDriveMqttGSensorDataItem::clear_y() {
  y_ = 0;
}
inline float CloudDriveMqttGSensorDataItem::y() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttGSensorDataItem.y)
  return y_;
}
inline void CloudDriveMqttGSensorDataItem::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttGSensorDataItem.y)
}

// float z = 4;
inline void CloudDriveMqttGSensorDataItem::clear_z() {
  z_ = 0;
}
inline float CloudDriveMqttGSensorDataItem::z() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttGSensorDataItem.z)
  return z_;
}
inline void CloudDriveMqttGSensorDataItem::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttGSensorDataItem.z)
}

// -------------------------------------------------------------------

// CloudDriveMqttGyroData

// repeated .io.nonda.onedata.proto.contract.CloudDriveMqttGyroDataItem items = 1;
inline int CloudDriveMqttGyroData::items_size() const {
  return items_.size();
}
inline void CloudDriveMqttGyroData::clear_items() {
  items_.Clear();
}
inline const ::io::nonda::onedata::proto::contract::CloudDriveMqttGyroDataItem& CloudDriveMqttGyroData::items(int index) const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttGyroData.items)
  return items_.Get(index);
}
inline ::io::nonda::onedata::proto::contract::CloudDriveMqttGyroDataItem* CloudDriveMqttGyroData::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:io.nonda.onedata.proto.contract.CloudDriveMqttGyroData.items)
  return items_.Mutable(index);
}
inline ::io::nonda::onedata::proto::contract::CloudDriveMqttGyroDataItem* CloudDriveMqttGyroData::add_items() {
  // @@protoc_insertion_point(field_add:io.nonda.onedata.proto.contract.CloudDriveMqttGyroData.items)
  return items_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::io::nonda::onedata::proto::contract::CloudDriveMqttGyroDataItem >*
CloudDriveMqttGyroData::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:io.nonda.onedata.proto.contract.CloudDriveMqttGyroData.items)
  return &items_;
}
inline const ::google::protobuf::RepeatedPtrField< ::io::nonda::onedata::proto::contract::CloudDriveMqttGyroDataItem >&
CloudDriveMqttGyroData::items() const {
  // @@protoc_insertion_point(field_list:io.nonda.onedata.proto.contract.CloudDriveMqttGyroData.items)
  return items_;
}

// -------------------------------------------------------------------

// CloudDriveMqttGyroDataItem

// int64 time = 1;
inline void CloudDriveMqttGyroDataItem::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CloudDriveMqttGyroDataItem::time() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttGyroDataItem.time)
  return time_;
}
inline void CloudDriveMqttGyroDataItem::set_time(::google::protobuf::int64 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttGyroDataItem.time)
}

// float x = 2;
inline void CloudDriveMqttGyroDataItem::clear_x() {
  x_ = 0;
}
inline float CloudDriveMqttGyroDataItem::x() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttGyroDataItem.x)
  return x_;
}
inline void CloudDriveMqttGyroDataItem::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttGyroDataItem.x)
}

// float y = 3;
inline void CloudDriveMqttGyroDataItem::clear_y() {
  y_ = 0;
}
inline float CloudDriveMqttGyroDataItem::y() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttGyroDataItem.y)
  return y_;
}
inline void CloudDriveMqttGyroDataItem::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttGyroDataItem.y)
}

// float z = 4;
inline void CloudDriveMqttGyroDataItem::clear_z() {
  z_ = 0;
}
inline float CloudDriveMqttGyroDataItem::z() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttGyroDataItem.z)
  return z_;
}
inline void CloudDriveMqttGyroDataItem::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttGyroDataItem.z)
}

// -------------------------------------------------------------------

// CloudDriveMqttFreqData

// int32 collectFreq = 1;
inline void CloudDriveMqttFreqData::clear_collectfreq() {
  collectfreq_ = 0;
}
inline ::google::protobuf::int32 CloudDriveMqttFreqData::collectfreq() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttFreqData.collectFreq)
  return collectfreq_;
}
inline void CloudDriveMqttFreqData::set_collectfreq(::google::protobuf::int32 value) {
  
  collectfreq_ = value;
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttFreqData.collectFreq)
}

// int32 reportFreq = 2;
inline void CloudDriveMqttFreqData::clear_reportfreq() {
  reportfreq_ = 0;
}
inline ::google::protobuf::int32 CloudDriveMqttFreqData::reportfreq() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttFreqData.reportFreq)
  return reportfreq_;
}
inline void CloudDriveMqttFreqData::set_reportfreq(::google::protobuf::int32 value) {
  
  reportfreq_ = value;
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttFreqData.reportFreq)
}

// -------------------------------------------------------------------

// CloudDriveMqttFaceData

// repeated .io.nonda.onedata.proto.contract.CloudDriveMqttFaceDataItem items = 1;
inline int CloudDriveMqttFaceData::items_size() const {
  return items_.size();
}
inline void CloudDriveMqttFaceData::clear_items() {
  items_.Clear();
}
inline const ::io::nonda::onedata::proto::contract::CloudDriveMqttFaceDataItem& CloudDriveMqttFaceData::items(int index) const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttFaceData.items)
  return items_.Get(index);
}
inline ::io::nonda::onedata::proto::contract::CloudDriveMqttFaceDataItem* CloudDriveMqttFaceData::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:io.nonda.onedata.proto.contract.CloudDriveMqttFaceData.items)
  return items_.Mutable(index);
}
inline ::io::nonda::onedata::proto::contract::CloudDriveMqttFaceDataItem* CloudDriveMqttFaceData::add_items() {
  // @@protoc_insertion_point(field_add:io.nonda.onedata.proto.contract.CloudDriveMqttFaceData.items)
  return items_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::io::nonda::onedata::proto::contract::CloudDriveMqttFaceDataItem >*
CloudDriveMqttFaceData::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:io.nonda.onedata.proto.contract.CloudDriveMqttFaceData.items)
  return &items_;
}
inline const ::google::protobuf::RepeatedPtrField< ::io::nonda::onedata::proto::contract::CloudDriveMqttFaceDataItem >&
CloudDriveMqttFaceData::items() const {
  // @@protoc_insertion_point(field_list:io.nonda.onedata.proto.contract.CloudDriveMqttFaceData.items)
  return items_;
}

// -------------------------------------------------------------------

// CloudDriveMqttFaceDataItem

// int64 time = 1;
inline void CloudDriveMqttFaceDataItem::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CloudDriveMqttFaceDataItem::time() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttFaceDataItem.time)
  return time_;
}
inline void CloudDriveMqttFaceDataItem::set_time(::google::protobuf::int64 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttFaceDataItem.time)
}

// int32 face = 2;
inline void CloudDriveMqttFaceDataItem::clear_face() {
  face_ = 0;
}
inline ::google::protobuf::int32 CloudDriveMqttFaceDataItem::face() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttFaceDataItem.face)
  return face_;
}
inline void CloudDriveMqttFaceDataItem::set_face(::google::protobuf::int32 value) {
  
  face_ = value;
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttFaceDataItem.face)
}

// -------------------------------------------------------------------

// CloudDriveMqttEmotionData

// repeated .io.nonda.onedata.proto.contract.CloudDriveMqttEmotionDataItem items = 1;
inline int CloudDriveMqttEmotionData::items_size() const {
  return items_.size();
}
inline void CloudDriveMqttEmotionData::clear_items() {
  items_.Clear();
}
inline const ::io::nonda::onedata::proto::contract::CloudDriveMqttEmotionDataItem& CloudDriveMqttEmotionData::items(int index) const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttEmotionData.items)
  return items_.Get(index);
}
inline ::io::nonda::onedata::proto::contract::CloudDriveMqttEmotionDataItem* CloudDriveMqttEmotionData::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:io.nonda.onedata.proto.contract.CloudDriveMqttEmotionData.items)
  return items_.Mutable(index);
}
inline ::io::nonda::onedata::proto::contract::CloudDriveMqttEmotionDataItem* CloudDriveMqttEmotionData::add_items() {
  // @@protoc_insertion_point(field_add:io.nonda.onedata.proto.contract.CloudDriveMqttEmotionData.items)
  return items_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::io::nonda::onedata::proto::contract::CloudDriveMqttEmotionDataItem >*
CloudDriveMqttEmotionData::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:io.nonda.onedata.proto.contract.CloudDriveMqttEmotionData.items)
  return &items_;
}
inline const ::google::protobuf::RepeatedPtrField< ::io::nonda::onedata::proto::contract::CloudDriveMqttEmotionDataItem >&
CloudDriveMqttEmotionData::items() const {
  // @@protoc_insertion_point(field_list:io.nonda.onedata.proto.contract.CloudDriveMqttEmotionData.items)
  return items_;
}

// -------------------------------------------------------------------

// CloudDriveMqttEmotionDataItem

// int64 time = 1;
inline void CloudDriveMqttEmotionDataItem::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CloudDriveMqttEmotionDataItem::time() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttEmotionDataItem.time)
  return time_;
}
inline void CloudDriveMqttEmotionDataItem::set_time(::google::protobuf::int64 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttEmotionDataItem.time)
}

// string emotion = 2;
inline void CloudDriveMqttEmotionDataItem::clear_emotion() {
  emotion_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CloudDriveMqttEmotionDataItem::emotion() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttEmotionDataItem.emotion)
  return emotion_.GetNoArena();
}
inline void CloudDriveMqttEmotionDataItem::set_emotion(const ::std::string& value) {
  
  emotion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttEmotionDataItem.emotion)
}
#if LANG_CXX11
inline void CloudDriveMqttEmotionDataItem::set_emotion(::std::string&& value) {
  
  emotion_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.nonda.onedata.proto.contract.CloudDriveMqttEmotionDataItem.emotion)
}
#endif
inline void CloudDriveMqttEmotionDataItem::set_emotion(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  emotion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.nonda.onedata.proto.contract.CloudDriveMqttEmotionDataItem.emotion)
}
inline void CloudDriveMqttEmotionDataItem::set_emotion(const char* value, size_t size) {
  
  emotion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.nonda.onedata.proto.contract.CloudDriveMqttEmotionDataItem.emotion)
}
inline ::std::string* CloudDriveMqttEmotionDataItem::mutable_emotion() {
  
  // @@protoc_insertion_point(field_mutable:io.nonda.onedata.proto.contract.CloudDriveMqttEmotionDataItem.emotion)
  return emotion_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CloudDriveMqttEmotionDataItem::release_emotion() {
  // @@protoc_insertion_point(field_release:io.nonda.onedata.proto.contract.CloudDriveMqttEmotionDataItem.emotion)
  
  return emotion_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CloudDriveMqttEmotionDataItem::set_allocated_emotion(::std::string* emotion) {
  if (emotion != NULL) {
    
  } else {
    
  }
  emotion_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), emotion);
  // @@protoc_insertion_point(field_set_allocated:io.nonda.onedata.proto.contract.CloudDriveMqttEmotionDataItem.emotion)
}

// -------------------------------------------------------------------

// CloudDriveMqttLogData

// string type = 1;
inline void CloudDriveMqttLogData::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CloudDriveMqttLogData::type() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttLogData.type)
  return type_.GetNoArena();
}
inline void CloudDriveMqttLogData::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttLogData.type)
}
#if LANG_CXX11
inline void CloudDriveMqttLogData::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.nonda.onedata.proto.contract.CloudDriveMqttLogData.type)
}
#endif
inline void CloudDriveMqttLogData::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.nonda.onedata.proto.contract.CloudDriveMqttLogData.type)
}
inline void CloudDriveMqttLogData::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.nonda.onedata.proto.contract.CloudDriveMqttLogData.type)
}
inline ::std::string* CloudDriveMqttLogData::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:io.nonda.onedata.proto.contract.CloudDriveMqttLogData.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CloudDriveMqttLogData::release_type() {
  // @@protoc_insertion_point(field_release:io.nonda.onedata.proto.contract.CloudDriveMqttLogData.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CloudDriveMqttLogData::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:io.nonda.onedata.proto.contract.CloudDriveMqttLogData.type)
}

// string msg = 2;
inline void CloudDriveMqttLogData::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CloudDriveMqttLogData::msg() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttLogData.msg)
  return msg_.GetNoArena();
}
inline void CloudDriveMqttLogData::set_msg(const ::std::string& value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttLogData.msg)
}
#if LANG_CXX11
inline void CloudDriveMqttLogData::set_msg(::std::string&& value) {
  
  msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:io.nonda.onedata.proto.contract.CloudDriveMqttLogData.msg)
}
#endif
inline void CloudDriveMqttLogData::set_msg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:io.nonda.onedata.proto.contract.CloudDriveMqttLogData.msg)
}
inline void CloudDriveMqttLogData::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:io.nonda.onedata.proto.contract.CloudDriveMqttLogData.msg)
}
inline ::std::string* CloudDriveMqttLogData::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:io.nonda.onedata.proto.contract.CloudDriveMqttLogData.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CloudDriveMqttLogData::release_msg() {
  // @@protoc_insertion_point(field_release:io.nonda.onedata.proto.contract.CloudDriveMqttLogData.msg)
  
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CloudDriveMqttLogData::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:io.nonda.onedata.proto.contract.CloudDriveMqttLogData.msg)
}

// -------------------------------------------------------------------

// CloudDriveMqttReportStatusData

// int32 type = 1;
inline void CloudDriveMqttReportStatusData::clear_type() {
  type_ = 0;
}
inline ::google::protobuf::int32 CloudDriveMqttReportStatusData::type() const {
  // @@protoc_insertion_point(field_get:io.nonda.onedata.proto.contract.CloudDriveMqttReportStatusData.type)
  return type_;
}
inline void CloudDriveMqttReportStatusData::set_type(::google::protobuf::int32 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:io.nonda.onedata.proto.contract.CloudDriveMqttReportStatusData.type)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace contract
}  // namespace proto
}  // namespace onedata
}  // namespace nonda
}  // namespace io

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CloudDriveMqttMessage_2eproto__INCLUDED
